---
slug: organize-your-translation-keys-with-tags
title: Organize Your Translation Keys Automatically with Tags!
description: A guide to the new Tolgee CLI feature that simplifies key organization with automatic extraction and tags.
authors: [sgranat]
tags: [tolgee, cli, tags, branching, tutorial]
---

Do you ever struggle with deprecated localization keys? Wondering which keys are active in production or still in draft pull requests? üòµ‚Äçüí´

Keeping localization keys organized in a large project can be a headache, especially with many contributors. But it‚Äôs crucial for a smooth localization process.

<!-- truncate-->

## The Challenge

One of my daily tasks at Tolgee Platform is tracking new localization keys. I need to identify keys linked to new features since they‚Äôre in "draft" mode. Until the feature is released, everything is fluid‚Äîstrings change, keys get added or removed, and sometimes entire features get scrapped. It‚Äôs easy to end up with unused keys that are forgotten and never removed.

## Manual Tagging of Keys

To tackle this, I tag each new key as `draft` during development, ideally removing the tag upon release. However, we often forget to remove the `draft` tag, mixing keys from different features, making it confusing and easy to overlook tags.

## The Bigger Picture

As we add new features, we inevitably have multiple versions (branches) of our application: the production version and development branches. It‚Äôs essential to know which keys belong to which branch since production keys require careful handling, while development keys can be modified or removed as needed.

## The Lifecycle of a Translation Key

Each key goes through a lifecycle:

1. Added to the code (`draft`)
2. Released to the public (`production`)
3. No longer needed (`deprecated`)

Different companies have different needs, but here‚Äôs the system we use at Tolgee:

### 1. `draft`

With the Tolgee SDK, you can set a default tag for new keys:

```ts
Tolgee().init({
  tagNewKeys: ['draft'],
})
```

When adding a new key through the Tolgee In-context tool, it appears like this:

![In-context with draft](/img/blog/tagging-keys/in-context-with-draft.png)

To manage multiple features, we store the branch name in a file, imported into our web application and used in the tag:

```ts
import { branchName } from './branch.json'

Tolgee().init({
  tagNewKeys: [`draft: ${branchName}`],
})
```

`branch.json`:
```json
{
  "branchName": "current-feature-branch"
}
```

We set up Git hooks to update this file automatically when switching branches:

1. Install Husky: `npm i -D husky` and run `npx husky init`
2. Add `post-commit` and `post-checkout` files to the `.husky` folder with this script:
```bash
echo "{\"branchName\": \"$(git rev-parse --abbrev-ref HEAD)\"}" > ../branch.json
```
3. Add `branch.json` to `.gitignore`

Now, `branch.json` updates according to your current branch, and new keys will have the correct `draft` tag.

### 2. `production` and `deprecated`

:::info
This part relies on your keys being [extractable by CLI](http://localhost:3000/tolgee-cli/extraction/syncing-strings), which means using Tolgee SDK and avoiding dynamic keys in your code.
:::

To track production keys, use the new CLI `tag` command, which extracts current keys from the code. We set this command in our GitHub Actions for every new commit in the `main` branch.

First, tag all production keys:

```sh
npx tolgee tag --filter-extracted --tag production --untag 'draft: *'
```

This moves the key from `draft` to `production`.

Next, identify `deprecated` keys:

```sh
npx tolgee tag \
  --filter-not-extracted --filter-tag production \
  --tag deprecated --untag production
```

This command filters keys **not** extracted but tagged as `production`, marking them as `deprecated`.

> Check our [GitHub release pipeline](https://github.com/tolgee/tolgee-platform/blob/main/.github/workflows/release.yml) for the full code.

## Why Not Branching?

We‚Äôve considered adding branching to Tolgee, where the platform mirrors your branches. However, this involves significant technical challenges and usability issues. Git itself, while powerful, is complex and constantly evolving‚Äîa testament to the inherent difficulty of version control.

By using tags and automated processes, we simplify localization key management without introducing the complexities of branching. This approach keeps our workflow efficient and our keys organized.